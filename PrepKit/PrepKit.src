// prepkit – a hybrid C-style preprocessor for GreyScript.
// 
// Enables modular code organization via `#import` directives.
// - Entry file uses native `import _code()` to avoid text size limits.
// - Nested imports are fully inlined, supporting deep includes and relative paths.
// 
// Supports:
//   - Relative and nested imports
//   - Plain `.src` files (binaries not supported)
//   - Single-file output suitable for compilation or inspection
// 
// Usage:
//   prepkit <source_file> [options]
// 
// Options:
//   -o <path>   Output folder path (default: alongside source)
//   -d          Dry run — process and merge files, but don’t write output
//   -i          Allow use of native `import_code` at top level

if params.len == 0 then
	print "prepkit – a hybrid C-style preprocessor for GreyScript."
	print "Enables modular code organization via `#import` directives."
	print ""
	print "Usage:"
	print "  prepkit [source file path] [options]"
	print ""
	print "Options:"
	print "  -o <output_folder>  Specify output directory (default: source file's folder)"
	print "  -d                  Dry run: inline imports without final compilation"
	print "  -i                  Allow native import_code at top level"
	exit()
end if

NEW_LINE = char(10)
CurrentShell = get_shell
HostComputer = CurrentShell.host_computer

// 
// Parses command-line arguments into a map of flags and their values.
// 
// Supports:
//   - Flags with values: -o /path
//   - Standalone flags:  -t (true)
// 
getCliFlags = function()
	flags = {}
	i = 0
	while i < params.len
		param = params[i]
		if param[0] == "-" then
			// Check the next param to see if it is a value(no "-") for the current param
			if i + 1 < params.len and params[i + 1][0] != "-" then
				flags[param] = params[i + 1]
				i = i + 1
			else
				flags[param] = true  // flag without a value
			end if
		end if
		i = i + 1
	end while

	return flags
end function

// 
// Resolves a relative path to an absolute path.
// 
// @param string relativePath    The relative path to resolve (e.g. "./folder/file.txt").
// @param string currentPath     (Optional) The base path to resolve from. If null, uses current working directory.
// @return                The resolved absolute path.
// 
resolvePath = function(relativePath, currentPath = null)
	if relativePath[0] == "/" then
		return relativePath  // already absolute
	end if

	if currentPath == null then
		currentPath = current_path
	end if

	pathComponents = relativePath.split("/")

	for component in pathComponents
		if component == "." then
			continue
		else if component == ".." then
			currentPath = parent_path(currentPath)
		else
			currentPath = currentPath + "/" + component
		end if
	end for

	return currentPath
end function

// Preps file for compilation.
// 
// @param File file     The file to process
// @param string dest   Destination folder path for output
// @return File       The prepped output file
// 
prepFile = function(file, dest, nestingLevel = 0)
	if not file.has_permission("r") then
		exit("Can not read file [" + file.path + "]: Read permission denied!")
	end if

	if nestingLevel != 0 then
		print "Linking import [" + file.name + "]"
	end if

	fileContents = file.get_content
	outputLines = []
	lines = fileContents.split(NEW_LINE)
	
	for line in lines
        lineContainsImport = line.indexOf("#import") != null
		if lineContainsImport then
			startQuote = line.indexOf("""")
			endQuote = line.lastIndexOf("""")
			
			if startQuote == null or endQuote == null or endQuote <= startQuote then
				exit("Invalid #import syntax in [" + file.path + "]:" + (outputLines.len + 1))
			end if

			importPath = slice(line, startQuote + 1, endQuote).trim
			
			if importPath.indexOf(".src") == null then
				importPath = importPath + ".src"
			end if
			
			importResolvedPath = resolvePath(importPath, file.parent.path)
			importedFile = HostComputer.File(importResolvedPath)
			if not importedFile then
				exit("Failed to import [" + importResolvedPath + "] in [" + file.path + "]:" + (outputLines.len + 1))
			end if
		
			if nestingLevel == 0 then
				importedFile = prepFile(importedFile, dest, nestingLevel + 1)
				outputLines.push("import" + "_code(""" + importedFile.path + """)") // The compiler sees "import_code" text and freaks out :D, se we split the word
			else
                importLines = prepFile(importedFile, dest, nestingLevel + 1)
                for importLine in importLines
                    outputLines.push(importLine)
                end for
			end if
		else
			outputLines.push(line)
		end if
	end for
	
    // Because starting from the first nest level, all imports are inlined, we make a copy of the original files
    // And move them next to the source file, starting with the level 2 nest level everything is inlined, 
    // and the file location does not matter anymore
	if nestingLevel < 2 then
        outputDest = dest + "/prepkit_out"
        if nestingLevel == 0 and not HostComputer.File(outputDest) then
            HostComputer.create_folder(dest, "prepkit_out")
        end if

		outputFileName = file.name
		outputPath = outputDest + "/" + outputFileName
		outputFile = HostComputer.File(outputPath)
		
		if outputFile == null then
			outputFileTouchResult = HostComputer.touch(outputDest, outputFileName)
			if outputFileTouchResult != 1 then
				exit("Failed to create output file [" + outputPath + "]: " + outputFileTouchResult)
			else
				outputFile = HostComputer.File(outputPath)
				if outputFile == null then
					exit("Failed to open output file: " + outputPath)
				end if
			end if
		end if 
			
		outputFile.set_content(outputLines.join(NEW_LINE))	
		return outputFile
	else
		return outputLines
	end if

end function

sourceFilePath = resolvePath(params[0])
sourceFile = HostComputer.File(sourceFilePath)
if not sourceFile then
	exit("Path Error: '" + sourceFilePath + "' is invalid!")
end if

if sourceFile.is_folder then
	exit("Path Error: '" + sourceFilePath + "' is a directory, expected a file.")
end if 

destinationPath = sourceFile.parent.path
cliFlags = getCliFlags()
if cliFlags.hasIndex("-o") then
	destinationResolvedPath = resolvePath(cliFlags["-o"])
	destinationPath = HostComputer.File(destinationResolvedPath)
	if not destinationPath then
		exit("Path Error: destination path ['" + destinationResolvedPath + "'] is invalid!")
	end if

	if not destinationPath.is_folder then
		exit("Path Error: '" + destinationPath.path + "' is a file, expected a directory.")
	end if 

	destinationPath = destinationPath.path
end if

dryRun = cliFlags.hasIndex("-d")
if dryRun then
	print "Dry run: inlining imports without final build output."
end if

inlinedSourceCodeFile = prepFile(sourceFile, sourceFile.parent.path)

if not dryRun then
	print("Compiling bundle...")
	buildErrors = CurrentShell.build(inlinedSourceCodeFile.path, destinationPath, cliFlags.hasIndex("-i"))
	inlinedSourceCodeFile.parent.delete
		
	if buildErrors != "" then
		exit("Build failed: " + buildErrors)
	end if

	print "Build finished: " + destinationPath
end if